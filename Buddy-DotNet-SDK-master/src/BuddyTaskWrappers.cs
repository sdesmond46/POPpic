#if AWAIT_SUPPORTED
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.17929
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace Buddy
{
    using System;
    using System.IO;
    using System.Collections.Generic;
    using BuddyServiceClient;
using System.Threading.Tasks;


   



    public static class CommerceTaskWrappers
    {

        /// <summary>
        /// Finds the receipt list based on the FromDateTime parameter for the currently logged in user.
        /// </summary>
        /// <param name="fromDateTime">The starting date and time to get receipts from, leave this blank to get all the receipts.</param>
        /// <returns>A Task&lt;IEnumerable&lt;Receipt&gt; &gt;that can be used to monitor progress on this call.</returns>
        public static System.Threading.Tasks.Task<IEnumerable<Receipt>> GetReceiptsForUserAsync(this Buddy.Commerce commerce, System.Nullable<System.DateTime> fromDateTime = null)
        {
            var tcs = new System.Threading.Tasks.TaskCompletionSource<IEnumerable<Receipt>>();
            commerce.GetReceiptsForUserInternal(fromDateTime, (bcr) =>
            {
                if (bcr.Error != BuddyServiceClient.BuddyError.None)
                {
                    tcs.TrySetException(new BuddyServiceException(bcr.Error));
                }
                else
                {
                    tcs.TrySetResult(bcr.Result);
                }
            });
            return tcs.Task;
        }

        /// <summary>
        /// Finds the receipt associated with the specified CustomTransactionID for the currently logged in user.
        /// </summary>
        /// <param name="customTransactionID">The CustomTransactionID of the transaction. For Facebook payments this is the OrderID of the transaction.</param>
        /// <returns>A Task&lt;IEnumerable&lt;Receipt&gt; &gt;that can be used to monitor progress on this call.</returns>
        public static System.Threading.Tasks.Task<IEnumerable<Receipt>> GetReceiptForUserAndTransactionIDAsync(this Buddy.Commerce commerce, string customTransactionID)
        {
            var tcs = new System.Threading.Tasks.TaskCompletionSource<IEnumerable<Receipt>>();
            commerce.GetReceiptForUserAndTransactionIDInternal(customTransactionID, (bcr) =>
            {
                if (bcr.Error != BuddyServiceClient.BuddyError.None)
                {
                    tcs.TrySetException(new BuddyServiceException(bcr.Error));
                }
                else
                {
                    tcs.TrySetResult(bcr.Result);
                }
            });
            return tcs.Task;
        }

        /// <summary>
        /// Saves a receipt for the purchase of an item made to the application's store.
        /// </summary>
        /// <param name="totalCost">The total cost for the items purchased in the transaction.</param>
        /// <param name="totalQuantity">The total number of items purchased.</param>
        /// <param name="storeItemID">The store ID of the item of the item being purchased.</param>
        /// <param name="storeName">The name of the application's store to be saved with the transaction. This field is used by the commerce analytics to track purchases.</param>
        /// <param name="receiptData">Optional information to store with the receipt such as notes about the transaction.</param>
        /// <param name="customTransactionID">An optional app-specific ID to associate with the purchase.</param>
        /// <param name="appData">Optional metadata to associate with the transaction.</param>
        /// <returns>A Task&lt;Boolean&gt;that can be used to monitor progress on this call.</returns>
        public static System.Threading.Tasks.Task<Boolean> SaveReceiptAsync(this Buddy.Commerce commerce, string totalCost, int totalQuantity, int storeItemID, string storeName, string receiptData = "", string customTransactionID = "", string appData = "")
        {
            var tcs = new System.Threading.Tasks.TaskCompletionSource<Boolean>();
            commerce.SaveReceiptInternal(totalCost, totalQuantity, storeItemID, storeName, receiptData, customTransactionID, appData, (bcr) =>
            {
                if (bcr.Error != BuddyServiceClient.BuddyError.None)
                {
                    tcs.TrySetException(new BuddyServiceException(bcr.Error));
                }
                else
                {
                    tcs.TrySetResult(bcr.Result);
                }
            });
            return tcs.Task;
        }

        /// <summary>
        /// Verifies that a receipt received from the Apple store is actually from Apple.
        /// </summary>
        /// <param name="totalCost">The total cost for the items purchased in the transaction.</param>
        /// <param name="totalQuantity">The total number of items purchased.</param>
        /// <param name="useSandbox">Set to true when testing this function in a "sandbox" to execute this call against the Apple sandbox server, or false to have the call executed against the production Apple server.</param>
        /// <param name="appleItemID">The optional ID associated with the item as assigned by Apple.</param>
        /// <param name="receiptData">Optional information to store with the receipt such as notes about the transaction.</param>
        /// <param name="customTransactionID">An optional app-specific ID to associate with the purchase.</param>
        /// <param name="appData">Optional metadata to associated with the transaction.</param>
        /// <returns>A Task&lt;Boolean&gt;that can be used to monitor progress on this call.</returns>
        public static System.Threading.Tasks.Task<Boolean> VerifyiOSReceiptAsync(this Buddy.Commerce commerce, string totalCost, int totalQuantity, bool useSandbox, string appleItemID = "", string receiptData = "", string customTransactionID = "", string appData = "")
        {
            var tcs = new System.Threading.Tasks.TaskCompletionSource<Boolean>();
            commerce.VerifyiOSReceiptInternal(totalCost, totalQuantity, useSandbox, appleItemID, receiptData, customTransactionID, appData, (bcr) =>
            {
                if (bcr.Error != BuddyServiceClient.BuddyError.None)
                {
                    tcs.TrySetException(new BuddyServiceException(bcr.Error));
                }
                else
                {
                    tcs.TrySetResult(bcr.Result);
                }
            });
            return tcs.Task;
        }

        /// <summary>
        /// Verifies that a receipt received from the Apple store is actually from Apple and stores a copy of the receipt on Buddy's servers.
        /// </summary>
        /// <param name="totalCost">The total cost for the items purchased in the transaction.</param>
        /// <param name="totalQuantity">The total number of items purchased.</param>
        /// <param name="useSandbox">Set to true when testing this function in a "sandbox" to execute this call against the Apple sandbox server, or false to have the call executed against the production Apple server.</param>
        /// <param name="appleItemID">The optional ID associated with the item as assigned by Apple.</param>
        /// <param name="receiptData">Optional information to store with the receipt such as notes about the transaction.</param>
        /// <param name="customTransactionID">An optional app-specific ID to associate with the purchase.</param>
        /// <param name="appData">Optional metadata to associated with the transaction.</param>
        /// <returns>A Task&lt;Boolean&gt;that can be used to monitor progress on this call.</returns>
        public static System.Threading.Tasks.Task<Boolean> VerifyAndSaveiOSReceiptAsync(this Buddy.Commerce commerce, string totalCost, int totalQuantity, bool useSandbox, string appleItemID = "", string receiptData = "", string customTransactionID = "", string appData = "")
        {
            var tcs = new System.Threading.Tasks.TaskCompletionSource<Boolean>();
            commerce.VerifyAndSaveiOSReceiptInternal(totalCost, totalQuantity, useSandbox, appleItemID, receiptData, customTransactionID, appData, (bcr) =>
            {
                if (bcr.Error != BuddyServiceClient.BuddyError.None)
                {
                    tcs.TrySetException(new BuddyServiceException(bcr.Error));
                }
                else
                {
                    tcs.TrySetResult(bcr.Result);
                }
            });
            return tcs.Task;
        }

        /// <summary>
        /// Returns information about all items in the store for the current application.
        /// </summary>
        /// <returns>A Task&lt;IEnumerable&lt;StoreItem&gt; &gt;that can be used to monitor progress on this call.</returns>
        public static System.Threading.Tasks.Task<IEnumerable<StoreItem>> GetAllStoreItemsAsync(this Buddy.Commerce commerce)
        {
            var tcs = new System.Threading.Tasks.TaskCompletionSource<IEnumerable<StoreItem>>();
            commerce.GetAllStoreItemsInternal((bcr) =>
            {
                if (bcr.Error != BuddyServiceClient.BuddyError.None)
                {
                    tcs.TrySetException(new BuddyServiceException(bcr.Error));
                }
                else
                {
                    tcs.TrySetResult(bcr.Result);
                }
            });
            return tcs.Task;
        }

        /// <summary>
        /// Returns information about all store items for an application which are currently active (available for sale).
        /// </summary>
        /// <returns>A Task&lt;IEnumerable&lt;StoreItem&gt; &gt;that can be used to monitor progress on this call.</returns>
        public static System.Threading.Tasks.Task<IEnumerable<StoreItem>> GetActiveStoreItemsAsync(this Buddy.Commerce commerce)
        {
            var tcs = new System.Threading.Tasks.TaskCompletionSource<IEnumerable<StoreItem>>();
            commerce.GetActiveStoreItemsInternal((bcr) =>
            {
                if (bcr.Error != BuddyServiceClient.BuddyError.None)
                {
                    tcs.TrySetException(new BuddyServiceException(bcr.Error));
                }
                else
                {
                    tcs.TrySetResult(bcr.Result);
                }
            });
            return tcs.Task;
        }

        /// <summary>
        /// Returns information about all items in the store for the current application which are marked as free.
        /// </summary>
        /// <returns>A Task&lt;IEnumerable&lt;StoreItem&gt; &gt;that can be used to monitor progress on this call.</returns>
        public static System.Threading.Tasks.Task<IEnumerable<StoreItem>> GetFreeStoreItemsAsync(this Buddy.Commerce commerce)
        {
            var tcs = new System.Threading.Tasks.TaskCompletionSource<IEnumerable<StoreItem>>();
            commerce.GetFreeStoreItemsInternal((bcr) =>
            {
                if (bcr.Error != BuddyServiceClient.BuddyError.None)
                {
                    tcs.TrySetException(new BuddyServiceException(bcr.Error));
                }
                else
                {
                    tcs.TrySetResult(bcr.Result);
                }
            });
            return tcs.Task;
        }
    }


    public static class FriendRequestsTaskWrappers
    {

        /// <summary>
        /// Add a friend request to a user.
        /// </summary>
        /// <param name="user">The user to send the request to, can't be null.</param>
        /// <param name="appTag">Mark this request with an tag, can be used on the user's side to make a decision on whether to accept the request.</param>
        /// <returns>A Task&lt;Boolean&gt;that can be used to monitor progress on this call.</returns>
        public static System.Threading.Tasks.Task<Boolean> AddAsync(this Buddy.FriendRequests friendRequests, Buddy.User user, string appTag = "")
        {
            var tcs = new System.Threading.Tasks.TaskCompletionSource<Boolean>();
            friendRequests.AddInternal(user, appTag, (bcr) =>
            {
                if (bcr.Error != BuddyServiceClient.BuddyError.None)
                {
                    tcs.TrySetException(new BuddyServiceException(bcr.Error));
                }
                else
                {
                    tcs.TrySetResult(bcr.Result);
                }
            });
            return tcs.Task;
        }

        /// <summary>
        /// A list of all users that have request to be friends with this user.
        /// </summary>
        /// <param name="afterDate">Filter the list by returning only the friend requests after a ceratin date.</param>
        /// <returns>A Task&lt;IEnumerable&lt;User&gt; &gt;that can be used to monitor progress on this call.</returns>
        public static System.Threading.Tasks.Task<IEnumerable<User>> GetAllAsync(this Buddy.FriendRequests friendRequests, System.DateTime afterDate = default(DateTime))
        {
            var tcs = new System.Threading.Tasks.TaskCompletionSource<IEnumerable<User>>();
            friendRequests.GetAllInternal(afterDate, (bcr) =>
            {
                if (bcr.Error != BuddyServiceClient.BuddyError.None)
                {
                    tcs.TrySetException(new BuddyServiceException(bcr.Error));
                }
                else
                {
                    tcs.TrySetResult(bcr.Result);
                }
            });
            return tcs.Task;
        }

        /// <summary>
        /// Accept a friend request from a user.
        /// </summary>
        /// <param name="user">The user to accept as friend. Can't be null and must be on the friend requests list.</param>
        /// <param name="appTag">Tag this friend accept with a string.</param>
        /// <returns>A Task&lt;Boolean&gt;that can be used to monitor progress on this call.</returns>
        public static System.Threading.Tasks.Task<Boolean> AcceptAsync(this Buddy.FriendRequests friendRequests, Buddy.User user, string appTag = "")
        {
            var tcs = new System.Threading.Tasks.TaskCompletionSource<Boolean>();
            friendRequests.AcceptInternal(user, appTag, (bcr) =>
            {
                if (bcr.Error != BuddyServiceClient.BuddyError.None)
                {
                    tcs.TrySetException(new BuddyServiceException(bcr.Error));
                }
                else
                {
                    tcs.TrySetResult(bcr.Result);
                }
            });
            return tcs.Task;
        }

        /// <summary>
        /// Deny the friend request from a user.
        /// </summary>
        /// <param name="user">The user to deny the friend request from. User can't be null and must be on the friend request list.</param>
        /// <returns>A Task&lt;Boolean&gt;that can be used to monitor progress on this call.</returns>
        public static System.Threading.Tasks.Task<Boolean> DenyAsync(this Buddy.FriendRequests friendRequests, Buddy.User user)
        {
            var tcs = new System.Threading.Tasks.TaskCompletionSource<Boolean>();
            friendRequests.DenyInternal(user, (bcr) =>
            {
                if (bcr.Error != BuddyServiceClient.BuddyError.None)
                {
                    tcs.TrySetException(new BuddyServiceException(bcr.Error));
                }
                else
                {
                    tcs.TrySetResult(bcr.Result);
                }
            });
            return tcs.Task;
        }
    }

    public static class FriendsTaskWrappers
    {

        /// <summary>
        /// Returns the list of friends for the user.
        /// </summary>
        /// <param name="afterDate">Filter the list by friends added 'afterDate'.</param>
        /// <returns>A Task&lt;IEnumerable&lt;User&gt; &gt;that can be used to monitor progress on this call.</returns>
        public static System.Threading.Tasks.Task<IEnumerable<User>> GetAllAsync(this Buddy.Friends friends, System.DateTime afterDate = default(DateTime))
        {
            var tcs = new System.Threading.Tasks.TaskCompletionSource<IEnumerable<User>>();
            friends.GetAllInternal(afterDate, (bcr) =>
            {
                if (bcr.Error != BuddyServiceClient.BuddyError.None)
                {
                    tcs.TrySetException(new BuddyServiceException(bcr.Error));
                }
                else
                {
                    tcs.TrySetResult(bcr.Result);
                }
            });
            return tcs.Task;
        }

        /// <summary>
        /// Remove a user from the current list of friends.
        /// </summary>
        /// <param name="user">The user to remove from the friends list. Must be already on the list and can't be null.</param>
        /// <returns>A Task&lt;Boolean&gt;that can be used to monitor progress on this call.</returns>
        public static System.Threading.Tasks.Task<Boolean> RemoveAsync(this Buddy.Friends friends, Buddy.User user)
        {
            var tcs = new System.Threading.Tasks.TaskCompletionSource<Boolean>();
            friends.RemoveInternal(user, (bcr) =>
            {
                if (bcr.Error != BuddyServiceClient.BuddyError.None)
                {
                    tcs.TrySetException(new BuddyServiceException(bcr.Error));
                }
                else
                {
                    tcs.TrySetResult(bcr.Result);
                }
            });
            return tcs.Task;
        }
    }


  

    public static class GameScoresTaskWrappers
    {

        /// <summary>
        /// Add a new score for this user.
        /// </summary>
        /// <param name="score">The numeric value of the score.</param>
        /// <param name="board">The optional name of the game board.</param>
        /// <param name="rank">The optional rank for this score. This can be used for adding badges, achievements, etc.</param>
        /// <param name="latitude">The optional latitude for this score.</param>
        /// <param name="longitude">The optional longitude for this score.</param>
        /// <param name="oneScorePerPlayer">The optional one-score-per-player paramter. Setting this to true will always update the score for this user, instead of creating a new one.</param>
        /// <param name="appTag">An optional application tag for this score.</param>
        /// <returns>A Task&lt;Boolean&gt;that can be used to monitor progress on this call.</returns>
        public static System.Threading.Tasks.Task<Boolean> AddAsync(this Buddy.GameScores gameScores, double score, string board = null, string rank = null, double latitude = 0, double longitude = 0, bool oneScorePerPlayer = false, string appTag = null)
        {
            var tcs = new System.Threading.Tasks.TaskCompletionSource<Boolean>();
            gameScores.AddInternal(score, board, rank, latitude, longitude, oneScorePerPlayer, appTag, (bcr) =>
            {
                if (bcr.Error != BuddyServiceClient.BuddyError.None)
                {
                    tcs.TrySetException(new BuddyServiceException(bcr.Error));
                }
                else
                {
                    tcs.TrySetResult(bcr.Result);
                }
            });
            return tcs.Task;
        }

        /// <summary>
        /// Delete all scores for this user.
        /// </summary>
        /// <returns>A Task&lt;Boolean&gt;that can be used to monitor progress on this call.</returns>
        public static System.Threading.Tasks.Task<Boolean> DeleteAllAsync(this Buddy.GameScores gameScores)
        {
            var tcs = new System.Threading.Tasks.TaskCompletionSource<Boolean>();
            gameScores.DeleteAllInternal((bcr) =>
            {
                if (bcr.Error != BuddyServiceClient.BuddyError.None)
                {
                    tcs.TrySetException(new BuddyServiceException(bcr.Error));
                }
                else
                {
                    tcs.TrySetResult(bcr.Result);
                }
            });
            return tcs.Task;
        }

        /// <summary>
        /// Return all score entries for this user.
        /// </summary>
        /// <param name="recordLimit">Limit the number of entries returned.</param>
        /// <returns>A Task&lt;IEnumerable&lt;GameScore&gt; &gt;that can be used to monitor progress on this call.</returns>
        public static System.Threading.Tasks.Task<IEnumerable<GameScore>> GetAllAsync(this Buddy.GameScores gameScores, int recordLimit = 100)
        {
            var tcs = new System.Threading.Tasks.TaskCompletionSource<IEnumerable<GameScore>>();
            gameScores.GetAllInternal(recordLimit, (bcr) =>
            {
                if (bcr.Error != BuddyServiceClient.BuddyError.None)
                {
                    tcs.TrySetException(new BuddyServiceException(bcr.Error));
                }
                else
                {
                    tcs.TrySetResult(bcr.Result);
                }
            });
            return tcs.Task;
        }
    }

    public static class GameStatesTaskWrappers
    {

        /// <summary>
        /// Adds a key/value pair to the User GameState.
        /// </summary>
        /// <param name="gameStateKey">The game state key.</param>
        /// <param name="gameStateValue">The value to persist.</param>
        /// <param name="appTag">An optional application tag for this score.</param>
        /// <returns>A Task&lt;Boolean&gt;that can be used to monitor progress on this call.</returns>
        public static System.Threading.Tasks.Task<Boolean> AddAsync(this Buddy.GameStates gameStates, string gameStateKey, string gameStateValue, string appTag = "")
        {
            var tcs = new System.Threading.Tasks.TaskCompletionSource<Boolean>();
            gameStates.AddInternal(gameStateKey, gameStateValue, appTag, (bcr) =>
            {
                if (bcr.Error != BuddyServiceClient.BuddyError.None)
                {
                    tcs.TrySetException(new BuddyServiceException(bcr.Error));
                }
                else
                {
                    tcs.TrySetResult(bcr.Result);
                }
            });
            return tcs.Task;
        }

        /// <summary>
        /// Get a GameState item with a key. The key can't be null or an empty string.
        /// </summary>
        /// <param name="gameStateKey">The gameStateKey to use to reference the GameState item.</param><exception cref="T:System.ArgumentException">When key is null or empty.</exception>
        /// <returns>A Task&lt;GameState&gt;that can be used to monitor progress on this call.</returns>
        public static System.Threading.Tasks.Task<GameState> GetAsync(this Buddy.GameStates gameStates, string gameStateKey)
        {
            var tcs = new System.Threading.Tasks.TaskCompletionSource<GameState>();
            gameStates.GetInternal(gameStateKey, (bcr) =>
            {
                if (bcr.Error != BuddyServiceClient.BuddyError.None)
                {
                    tcs.TrySetException(new BuddyServiceException(bcr.Error));
                }
                else
                {
                    tcs.TrySetResult(bcr.Result);
                }
            });
            return tcs.Task;
        }

        /// <summary>
        /// Update a GameState value.
        /// </summary>
        /// <param name="gameStateKey">The key to update.</param>
        /// <param name="gameStateValue">The value to update.</param>
        /// <param name="newAppTag">An optional new application tag for the value.</param>
        /// <returns>A Task&lt;Boolean&gt;that can be used to monitor progress on this call.</returns>
        public static System.Threading.Tasks.Task<Boolean> UpdateAsync(this Buddy.GameStates gameStates, string gameStateKey, string gameStateValue, string newAppTag = "")
        {
            var tcs = new System.Threading.Tasks.TaskCompletionSource<Boolean>();
            gameStates.UpdateInternal(gameStateKey, gameStateValue, newAppTag, (bcr) =>
            {
                if (bcr.Error != BuddyServiceClient.BuddyError.None)
                {
                    tcs.TrySetException(new BuddyServiceException(bcr.Error));
                }
                else
                {
                    tcs.TrySetResult(bcr.Result);
                }
            });
            return tcs.Task;
        }

        /// <summary>
        /// Remove a GameState key.
        /// </summary>
        /// <param name="gameStateKey">The key to remove from the GameState.</param>
        /// <returns>A Task&lt;Boolean&gt;that can be used to monitor progress on this call.</returns>
        public static System.Threading.Tasks.Task<Boolean> RemoveAsync(this Buddy.GameStates gameStates, string gameStateKey)
        {
            var tcs = new System.Threading.Tasks.TaskCompletionSource<Boolean>();
            gameStates.RemoveInternal(gameStateKey, (bcr) =>
            {
                if (bcr.Error != BuddyServiceClient.BuddyError.None)
                {
                    tcs.TrySetException(new BuddyServiceException(bcr.Error));
                }
                else
                {
                    tcs.TrySetResult(bcr.Result);
                }
            });
            return tcs.Task;
        }

        /// <summary>
        /// Get all GameState keys and values.
        /// </summary>
        /// <returns>A Task&lt;IDictionary&lt;String,GameState&gt; &gt;that can be used to monitor progress on this call.</returns>
        public static System.Threading.Tasks.Task<IDictionary<String, GameState>> GetAllAsync(this Buddy.GameStates gameStates)
        {
            var tcs = new System.Threading.Tasks.TaskCompletionSource<IDictionary<String, GameState>>();
            gameStates.GetAllInternal((bcr) =>
            {
                if (bcr.Error != BuddyServiceClient.BuddyError.None)
                {
                    tcs.TrySetException(new BuddyServiceException(bcr.Error));
                }
                else
                {
                    tcs.TrySetResult(bcr.Result);
                }
            });
            return tcs.Task;
        }
    }

    public static class IdentityTaskWrappers
    {

        /// <summary>
        /// Returns all the identity values for this user.
        /// </summary>
        /// <returns>A Task&lt;IEnumerable&lt;IdentityItem&gt; &gt;that can be used to monitor progress on this call.</returns>
        public static System.Threading.Tasks.Task<IEnumerable<IdentityItem>> GetAllAsync(this Buddy.Identity identity)
        {
            var tcs = new System.Threading.Tasks.TaskCompletionSource<IEnumerable<IdentityItem>>();
            identity.GetAllInternal((bcr) =>
            {
                if (bcr.Error != BuddyServiceClient.BuddyError.None)
                {
                    tcs.TrySetException(new BuddyServiceException(bcr.Error));
                }
                else
                {
                    tcs.TrySetResult(bcr.Result);
                }
            });
            return tcs.Task;
        }

        /// <summary>
        /// Add an identity value for this user.
        /// </summary>
        /// <param name="value">The value to add.</param>
        /// <returns>A Task&lt;Boolean&gt;that can be used to monitor progress on this call.</returns>
        public static System.Threading.Tasks.Task<Boolean> AddAsync(this Buddy.Identity identity, string value)
        {
            var tcs = new System.Threading.Tasks.TaskCompletionSource<Boolean>();
            identity.AddInternal(value, (bcr) =>
            {
                if (bcr.Error != BuddyServiceClient.BuddyError.None)
                {
                    tcs.TrySetException(new BuddyServiceException(bcr.Error));
                }
                else
                {
                    tcs.TrySetResult(bcr.Result);
                }
            });
            return tcs.Task;
        }

        /// <summary>
        /// Remove an identity value for this user.
        /// </summary>
        /// <param name="value">The value to remove.</param>
        /// <returns>A Task&lt;Boolean&gt;that can be used to monitor progress on this call.</returns>
        public static System.Threading.Tasks.Task<Boolean> RemoveAsync(this Buddy.Identity identity, string value)
        {
            var tcs = new System.Threading.Tasks.TaskCompletionSource<Boolean>();
            identity.RemoveInternal(value, (bcr) =>
            {
                if (bcr.Error != BuddyServiceClient.BuddyError.None)
                {
                    tcs.TrySetException(new BuddyServiceException(bcr.Error));
                }
                else
                {
                    tcs.TrySetResult(bcr.Result);
                }
            });
            return tcs.Task;
        }

        /// <summary>
        /// Check for the existance of an identity value in the system. The search is perform for the entire app.
        /// </summary>
        /// <param name="values">The value to search for. This can either be a single value or a semi-colon separated list of values.</param>
        /// <returns>A Task&lt;IEnumerable&lt;IdentityItemSearchResult&gt; &gt;that can be used to monitor progress on this call.</returns>
        public static System.Threading.Tasks.Task<IEnumerable<IdentityItemSearchResult>> CheckForValuesAsync(this Buddy.Identity identity, string values)
        {
            var tcs = new System.Threading.Tasks.TaskCompletionSource<IEnumerable<IdentityItemSearchResult>>();
            identity.CheckForValuesInternal(values, (bcr) =>
            {
                if (bcr.Error != BuddyServiceClient.BuddyError.None)
                {
                    tcs.TrySetException(new BuddyServiceException(bcr.Error));
                }
                else
                {
                    tcs.TrySetResult(bcr.Result);
                }
            });
            return tcs.Task;
        }
    }

    public static class MessageGroupTaskWrappers
    {

        /// <summary>
        /// This method has the current user join this message group.
        /// </summary>
        /// <returns>A Task&lt;Boolean&gt;that can be used to monitor progress on this call.</returns>
        public static System.Threading.Tasks.Task<Boolean> JoinAsync(this Buddy.MessageGroup messageGroup)
        {
            var tcs = new System.Threading.Tasks.TaskCompletionSource<Boolean>();
            messageGroup.JoinInternal((bcr) =>
            {
                if (bcr.Error != BuddyServiceClient.BuddyError.None)
                {
                    tcs.TrySetException(new BuddyServiceException(bcr.Error));
                }
                else
                {
                    tcs.TrySetResult(bcr.Result);
                }
            });
            return tcs.Task;
        }

        /// <summary>
        /// This methods has the current user leave this message group.
        /// </summary>
        /// <returns>A Task&lt;Boolean&gt;that can be used to monitor progress on this call.</returns>
        public static System.Threading.Tasks.Task<Boolean> LeaveAsync(this Buddy.MessageGroup messageGroup)
        {
            var tcs = new System.Threading.Tasks.TaskCompletionSource<Boolean>();
            messageGroup.LeaveInternal((bcr) =>
            {
                if (bcr.Error != BuddyServiceClient.BuddyError.None)
                {
                    tcs.TrySetException(new BuddyServiceException(bcr.Error));
                }
                else
                {
                    tcs.TrySetResult(bcr.Result);
                }
            });
            return tcs.Task;
        }

        /// <summary>
        /// Add a user to this message group. 
        /// </summary>
        /// <param name="userToAdd">The User to add to the message group.</param>
        /// <returns>A Task&lt;Boolean&gt;that can be used to monitor progress on this call.</returns>
        public static System.Threading.Tasks.Task<Boolean> AddUserAsync(this Buddy.MessageGroup messageGroup, Buddy.User userToAdd)
        {
            var tcs = new System.Threading.Tasks.TaskCompletionSource<Boolean>();
            messageGroup.AddUserInternal(userToAdd, (bcr) =>
            {
                if (bcr.Error != BuddyServiceClient.BuddyError.None)
                {
                    tcs.TrySetException(new BuddyServiceException(bcr.Error));
                }
                else
                {
                    tcs.TrySetResult(bcr.Result);
                }
            });
            return tcs.Task;
        }

        /// <summary>
        /// Remove a user from this message group.
        /// </summary>
        /// <param name="userToRemove">The user to remove from the group.</param>
        /// <returns>A Task&lt;Boolean&gt;that can be used to monitor progress on this call.</returns>
        public static System.Threading.Tasks.Task<Boolean> RemoveUserAsync(this Buddy.MessageGroup messageGroup, Buddy.User userToRemove)
        {
            var tcs = new System.Threading.Tasks.TaskCompletionSource<Boolean>();
            messageGroup.RemoveUserInternal(userToRemove, (bcr) =>
            {
                if (bcr.Error != BuddyServiceClient.BuddyError.None)
                {
                    tcs.TrySetException(new BuddyServiceException(bcr.Error));
                }
                else
                {
                    tcs.TrySetResult(bcr.Result);
                }
            });
            return tcs.Task;
        }

        /// <summary>
        /// Send a message to the entire message group.
        /// </summary>
        /// <param name="message">The message to send to this group. Must be less then 1000 characters.</param>
        /// <param name="latitude">The optional latitude from where this message was sent.</param>
        /// <param name="longitude">The optional longitude from where this message was sent.</param>
        /// <param name="appTag">An optional application tag for this message.</param>
        /// <returns>A Task&lt;IDictionary&lt;Int32,Boolean&gt; &gt;that can be used to monitor progress on this call.</returns>
        public static System.Threading.Tasks.Task<IDictionary<Int32, Boolean>> SendMessageAsync(this Buddy.MessageGroup messageGroup, string message, double latitude = 0, double longitude = 0, string appTag = "")
        {
            var tcs = new System.Threading.Tasks.TaskCompletionSource<IDictionary<Int32, Boolean>>();
            messageGroup.SendMessageInternal(message, latitude, longitude, appTag, (bcr) =>
            {
                if (bcr.Error != BuddyServiceClient.BuddyError.None)
                {
                    tcs.TrySetException(new BuddyServiceException(bcr.Error));
                }
                else
                {
                    tcs.TrySetResult(bcr.Result);
                }
            });
            return tcs.Task;
        }

        /// <summary>
        /// Get all messages this group has received.
        /// </summary>
        /// <param name="afterDate">Optionally return only messages sent after this date.</param>
        /// <returns>A Task&lt;IEnumerable&lt;GroupMessage&gt; &gt;that can be used to monitor progress on this call.</returns>
        public static System.Threading.Tasks.Task<IEnumerable<GroupMessage>> GetReceivedAsync(this Buddy.MessageGroup messageGroup, System.DateTime afterDate = default(DateTime))
        {
            var tcs = new System.Threading.Tasks.TaskCompletionSource<IEnumerable<GroupMessage>>();
            messageGroup.GetReceivedInternal(afterDate, (bcr) =>
            {
                if (bcr.Error != BuddyServiceClient.BuddyError.None)
                {
                    tcs.TrySetException(new BuddyServiceException(bcr.Error));
                }
                else
                {
                    tcs.TrySetResult(bcr.Result);
                }
            });
            return tcs.Task;
        }

        /// <summary>
        /// Delete this message group.
        /// </summary>
        /// <returns>A Task&lt;Boolean&gt;that can be used to monitor progress on this call.</returns>
        public static System.Threading.Tasks.Task<Boolean> DeleteAsync(this Buddy.MessageGroup messageGroup)
        {
            var tcs = new System.Threading.Tasks.TaskCompletionSource<Boolean>();
            messageGroup.DeleteInternal((bcr) =>
            {
                if (bcr.Error != BuddyServiceClient.BuddyError.None)
                {
                    tcs.TrySetException(new BuddyServiceException(bcr.Error));
                }
                else
                {
                    tcs.TrySetResult(bcr.Result);
                }
            });
            return tcs.Task;
        }
    }

    public static class MessageGroupsTaskWrappers
    {

        /// <summary>
        /// Create a new message group.
        /// </summary>
        /// <param name="name">The name of the new group, must be unique for the app.</param>
        /// <param name="openGroup">Optionally whether to make to group open for all user (anyone can join), or closed (only the owner can add users to it).</param>
        /// <param name="appTag">An optional application tag for this message group.</param>
        /// <returns>A Task&lt;MessageGroup&gt;that can be used to monitor progress on this call.</returns>
        public static System.Threading.Tasks.Task<MessageGroup> CreateAsync(this Buddy.MessageGroups messageGroups, string name, bool openGroup, string appTag = "")
        {
            var tcs = new System.Threading.Tasks.TaskCompletionSource<MessageGroup>();
            messageGroups.CreateInternal(name, openGroup, appTag, (bcr) =>
            {
                if (bcr.Error != BuddyServiceClient.BuddyError.None)
                {
                    tcs.TrySetException(new BuddyServiceException(bcr.Error));
                }
                else
                {
                    tcs.TrySetResult(bcr.Result);
                }
            });
            return tcs.Task;
        }

        /// <summary>
        /// Check if a group with this name already exists.
        /// </summary>
        /// <param name="name">The name of the group to check for.</param>
        /// <returns>A Task&lt;Boolean&gt;that can be used to monitor progress on this call.</returns>
        public static System.Threading.Tasks.Task<Boolean> CheckIfExistsAsync(this Buddy.MessageGroups messageGroups, string name)
        {
            var tcs = new System.Threading.Tasks.TaskCompletionSource<Boolean>();
            messageGroups.CheckIfExistsInternal(name, (bcr) =>
            {
                if (bcr.Error != BuddyServiceClient.BuddyError.None)
                {
                    tcs.TrySetException(new BuddyServiceException(bcr.Error));
                }
                else
                {
                    tcs.TrySetResult(bcr.Result);
                }
            });
            return tcs.Task;
        }

        /// <summary>
        /// Get all message groups for this app.
        /// </summary>
        /// <returns>A Task&lt;IEnumerable&lt;MessageGroup&gt; &gt;that can be used to monitor progress on this call.</returns>
        public static System.Threading.Tasks.Task<IEnumerable<MessageGroup>> GetAllAsync(this Buddy.MessageGroups messageGroups)
        {
            var tcs = new System.Threading.Tasks.TaskCompletionSource<IEnumerable<MessageGroup>>();
            messageGroups.GetAllInternal((bcr) =>
            {
                if (bcr.Error != BuddyServiceClient.BuddyError.None)
                {
                    tcs.TrySetException(new BuddyServiceException(bcr.Error));
                }
                else
                {
                    tcs.TrySetResult(bcr.Result);
                }
            });
            return tcs.Task;
        }

        /// <summary>
        /// Get all message groups that this user is part of.
        /// </summary>
        /// <returns>A Task&lt;IEnumerable&lt;MessageGroup&gt; &gt;that can be used to monitor progress on this call.</returns>
        public static System.Threading.Tasks.Task<IEnumerable<MessageGroup>> GetMyAsync(this Buddy.MessageGroups messageGroups)
        {
            var tcs = new System.Threading.Tasks.TaskCompletionSource<IEnumerable<MessageGroup>>();
            messageGroups.GetMyInternal((bcr) =>
            {
                if (bcr.Error != BuddyServiceClient.BuddyError.None)
                {
                    tcs.TrySetException(new BuddyServiceException(bcr.Error));
                }
                else
                {
                    tcs.TrySetResult(bcr.Result);
                }
            });
            return tcs.Task;
        }
    }

    public static class MessagesTaskWrappers
    {

        /// <summary>
        /// Send a message to a user from the current authenticated user.
        /// </summary>
        /// <param name="toUser">The user to send a message to.</param>
        /// <param name="message">The message to send, must be less then 200 characters.</param>
        /// <param name="appTag">An optional application tag to set for the message.</param>
        /// <returns>A Task&lt;Boolean&gt;that can be used to monitor progress on this call.</returns>
        public static System.Threading.Tasks.Task<Boolean> SendAsync(this Buddy.Messages messages, Buddy.User toUser, string message, string appTag = "")
        {
            var tcs = new System.Threading.Tasks.TaskCompletionSource<Boolean>();
            messages.SendInternal(toUser, message, appTag, (bcr) =>
            {
                if (bcr.Error != BuddyServiceClient.BuddyError.None)
                {
                    tcs.TrySetException(new BuddyServiceException(bcr.Error));
                }
                else
                {
                    tcs.TrySetResult(bcr.Result);
                }
            });
            return tcs.Task;
        }

        /// <summary>
        /// Get all received message by the current user.
        /// </summary>
        /// <param name="afterDate">Optionally retreive only messages after a certain DateTime.</param>
        /// <returns>A Task&lt;IEnumerable&lt;Message&gt; &gt;that can be used to monitor progress on this call.</returns>
        public static System.Threading.Tasks.Task<IEnumerable<Message>> GetReceivedAsync(this Buddy.Messages messages, System.DateTime afterDate = default(DateTime))
        {
            var tcs = new System.Threading.Tasks.TaskCompletionSource<IEnumerable<Message>>();
            messages.GetReceivedInternal(afterDate, (bcr) =>
            {
                if (bcr.Error != BuddyServiceClient.BuddyError.None)
                {
                    tcs.TrySetException(new BuddyServiceException(bcr.Error));
                }
                else
                {
                    tcs.TrySetResult(bcr.Result);
                }
            });
            return tcs.Task;
        }

        /// <summary>
        /// Get all sent message by the current user.
        /// </summary>
        /// <param name="afterDate">Optionally retreive only messages after a certain DateTime.</param>
        /// <returns>A Task&lt;IEnumerable&lt;Message&gt; &gt;that can be used to monitor progress on this call.</returns>
        public static System.Threading.Tasks.Task<IEnumerable<Message>> GetSentAsync(this Buddy.Messages messages, System.DateTime afterDate = default(DateTime))
        {
            var tcs = new System.Threading.Tasks.TaskCompletionSource<IEnumerable<Message>>();
            messages.GetSentInternal(afterDate, (bcr) =>
            {
                if (bcr.Error != BuddyServiceClient.BuddyError.None)
                {
                    tcs.TrySetException(new BuddyServiceException(bcr.Error));
                }
                else
                {
                    tcs.TrySetResult(bcr.Result);
                }
            });
            return tcs.Task;
        }
    }

    public static class MetadataItemTaskWrappers
    {

        /// <summary>
        /// Updates the value of this metadata item.
        /// </summary>
        /// <param name="value">The new value for this item, can't be null.</param>
        /// <param name="latitude">The optional latitude for this item.</param>
        /// <param name="longitude">The optional longitude for this item.</param>
        /// <param name="appTag">The optional application tag for this item.</param>
        /// <returns>A Task&lt;Boolean&gt;that can be used to monitor progress on this call.</returns>
        public static System.Threading.Tasks.Task<Boolean> SetAsync(this Buddy.MetadataItem metadataItem, string value, double latitude = 0, double longitude = 0, string appTag = "")
        {
            var tcs = new System.Threading.Tasks.TaskCompletionSource<Boolean>();
            metadataItem.SetInternal(value, latitude, longitude, appTag, (bcr) =>
            {
                if (bcr.Error != BuddyServiceClient.BuddyError.None)
                {
                    tcs.TrySetException(new BuddyServiceException(bcr.Error));
                }
                else
                {
                    tcs.TrySetResult(bcr.Result);
                }
            });
            return tcs.Task;
        }

        /// <summary>
        /// Deletes this metadata item.
        /// </summary>
        /// <returns>A Task&lt;Boolean&gt;that can be used to monitor progress on this call.</returns>
        public static System.Threading.Tasks.Task<Boolean> DeleteAsync(this Buddy.MetadataItem metadataItem)
        {
            var tcs = new System.Threading.Tasks.TaskCompletionSource<Boolean>();
            metadataItem.DeleteInternal((bcr) =>
            {
                if (bcr.Error != BuddyServiceClient.BuddyError.None)
                {
                    tcs.TrySetException(new BuddyServiceException(bcr.Error));
                }
                else
                {
                    tcs.TrySetResult(bcr.Result);
                }
            });
            return tcs.Task;
        }
    }

  

    public static class NotificationsAndroidTaskWrappers
    {

        /// <summary>
        /// Register an Android device for notificatons with Buddy. 
        /// </summary>
        /// <param name="registrationID">The registration ID for the application currently running on the device. Note: this is the registration ID returned after registering with C2DM.</param>
        /// <param name="groupName">Register this device as part of a group, so that you can send the whole group messages.</param>
        /// <returns>A Task&lt;Boolean&gt;that can be used to monitor progress on this call.</returns>
        public static System.Threading.Tasks.Task<Boolean> RegisterDeviceAsync(this Buddy.NotificationsAndroid notificationsAndroid, string registrationID, string groupName = "")
        {
            var tcs = new System.Threading.Tasks.TaskCompletionSource<Boolean>();
            notificationsAndroid.RegisterDeviceInternal(registrationID, groupName, (bcr) =>
            {
                if (bcr.Error != BuddyServiceClient.BuddyError.None)
                {
                    tcs.TrySetException(new BuddyServiceException(bcr.Error));
                }
                else
                {
                    tcs.TrySetResult(bcr.Result);
                }
            });
            return tcs.Task;
        }

        /// <summary>
        /// Unregister the current user from push notifications for Android.
        /// </summary>
        /// <returns>A Task&lt;Boolean&gt;that can be used to monitor progress on this call.</returns>
        public static System.Threading.Tasks.Task<Boolean> UnregisterDeviceAsync(this Buddy.NotificationsAndroid notificationsAndroid)
        {
            var tcs = new System.Threading.Tasks.TaskCompletionSource<Boolean>();
            notificationsAndroid.UnregisterDeviceInternal((bcr) =>
            {
                if (bcr.Error != BuddyServiceClient.BuddyError.None)
                {
                    tcs.TrySetException(new BuddyServiceException(bcr.Error));
                }
                else
                {
                    tcs.TrySetResult(bcr.Result);
                }
            });
            return tcs.Task;
        }

        /// <summary>
        /// Get a paged list of registered Android devices for this Application. This list can then be used to iterate over the devices and send each user a push notification.
        /// </summary>
        /// <param name="forGroup">Optionally filter only devices in a certain group.</param>
        /// <param name="pageSize">Set the number of devices that will be returned for each call of this method.</param>
        /// <param name="currentPage">Set the current page.</param>
        /// <returns>A Task&lt;IEnumerable&lt;RegisteredDeviceAndroid&gt; &gt;that can be used to monitor progress on this call.</returns>
        public static System.Threading.Tasks.Task<IEnumerable<RegisteredDeviceAndroid>> GetRegisteredDevicesAsync(this Buddy.NotificationsAndroid notificationsAndroid, string forGroup = "", int pageSize = 10, int currentPage = 1)
        {
            var tcs = new System.Threading.Tasks.TaskCompletionSource<IEnumerable<RegisteredDeviceAndroid>>();
            notificationsAndroid.GetRegisteredDevicesInternal(forGroup, pageSize, currentPage, (bcr) =>
            {
                if (bcr.Error != BuddyServiceClient.BuddyError.None)
                {
                    tcs.TrySetException(new BuddyServiceException(bcr.Error));
                }
                else
                {
                    tcs.TrySetResult(bcr.Result);
                }
            });
            return tcs.Task;
        }

        /// <summary>
        /// Get a list of Android groups that have been registered with Buddy as well as the number of users in each group. Groups can be used to batch-send
        /// push notifications to a number of users at the same time.
        /// </summary>
        /// <returns>A Task&lt;IDictionary&lt;String,Int32&gt; &gt;that can be used to monitor progress on this call.</returns>
        public static System.Threading.Tasks.Task<IDictionary<String, Int32>> GetGroupsAsync(this Buddy.NotificationsAndroid notificationsAndroid)
        {
            var tcs = new System.Threading.Tasks.TaskCompletionSource<IDictionary<String, Int32>>();
            notificationsAndroid.GetGroupsInternal((bcr) =>
            {
                if (bcr.Error != BuddyServiceClient.BuddyError.None)
                {
                    tcs.TrySetException(new BuddyServiceException(bcr.Error));
                }
                else
                {
                    tcs.TrySetResult(bcr.Result);
                }
            });
            return tcs.Task;
        }

        /// <summary>
        /// Send a raw message to a Android device. Note that this call does not directly send the message but rather, adds the raw message to the queue of messages to be sent.
        /// </summary>
        /// <param name="rawMessage">The message to send.</param>
        /// <param name="senderUserId">The ID of the user that sent the notification.</param>
        /// <param name="deliverAfter">Schedule the message to be delivered after a certain date.</param>
        /// <param name="groupName">Send messages to an entire group of users, not just a one.</param>
        /// <returns>A Task&lt;Boolean&gt;that can be used to monitor progress on this call.</returns>
        public static System.Threading.Tasks.Task<Boolean> SendRawMessageAsync(this Buddy.NotificationsAndroid notificationsAndroid, string rawMessage, int senderUserId, System.DateTime deliverAfter = default(DateTime), string groupName = "")
        {
            var tcs = new System.Threading.Tasks.TaskCompletionSource<Boolean>();
            notificationsAndroid.SendRawMessageInternal(rawMessage, senderUserId, deliverAfter, groupName, (bcr) =>
            {
                if (bcr.Error != BuddyServiceClient.BuddyError.None)
                {
                    tcs.TrySetException(new BuddyServiceException(bcr.Error));
                }
                else
                {
                    tcs.TrySetResult(bcr.Result);
                }
            });
            return tcs.Task;
        }
    }

    public static class NotificationsAppleTaskWrappers
    {

        /// <summary>
        /// Register an Apple device for notificatons with Buddy. 
        /// </summary>
        /// <param name="appleDeviceToken">A token provided by the Apple Push Notification Service (APNs) which identifies the device to register (analogous to a phone number).</param>
        /// <param name="groupName">Register this device as part of a group, so that you can send the whole group messages.</param>
        /// <returns>A Task&lt;Boolean&gt;that can be used to monitor progress on this call.</returns>
        public static System.Threading.Tasks.Task<Boolean> RegisterDeviceAsync(this Buddy.NotificationsApple notificationsApple, string appleDeviceToken, string groupName = "")
        {
            var tcs = new System.Threading.Tasks.TaskCompletionSource<Boolean>();
            notificationsApple.RegisterDeviceInternal(appleDeviceToken, groupName, (bcr) =>
            {
                if (bcr.Error != BuddyServiceClient.BuddyError.None)
                {
                    tcs.TrySetException(new BuddyServiceException(bcr.Error));
                }
                else
                {
                    tcs.TrySetResult(bcr.Result);
                }
            });
            return tcs.Task;
        }

        /// <summary>
        /// Unregister the current user from push notifications for Apple devices.
        /// </summary>
        /// <returns>A Task&lt;Boolean&gt;that can be used to monitor progress on this call.</returns>
        public static System.Threading.Tasks.Task<Boolean> UnregisterDeviceAsync(this Buddy.NotificationsApple notificationsApple)
        {
            var tcs = new System.Threading.Tasks.TaskCompletionSource<Boolean>();
            notificationsApple.UnregisterDeviceInternal((bcr) =>
            {
                if (bcr.Error != BuddyServiceClient.BuddyError.None)
                {
                    tcs.TrySetException(new BuddyServiceException(bcr.Error));
                }
                else
                {
                    tcs.TrySetResult(bcr.Result);
                }
            });
            return tcs.Task;
        }

        /// <summary>
        /// Get a paged list of registered Apple devices for this Application. This list can then be used to iterate over the devices and send each user a push notification.
        /// </summary>
        /// <param name="forGroup">Optionally filter only devices in a certain group.</param>
        /// <param name="pageSize">Set the number of devices that will be returned for each call of this method.</param>
        /// <param name="currentPage">Set the current page.</param>
        /// <returns>A Task&lt;IEnumerable&lt;RegisteredDeviceApple&gt; &gt;that can be used to monitor progress on this call.</returns>
        public static System.Threading.Tasks.Task<IEnumerable<RegisteredDeviceApple>> GetRegisteredDevicesAsync(this Buddy.NotificationsApple notificationsApple, string forGroup = "", int pageSize = 10, int currentPage = 1)
        {
            var tcs = new System.Threading.Tasks.TaskCompletionSource<IEnumerable<RegisteredDeviceApple>>();
            notificationsApple.GetRegisteredDevicesInternal(forGroup, pageSize, currentPage, (bcr) =>
            {
                if (bcr.Error != BuddyServiceClient.BuddyError.None)
                {
                    tcs.TrySetException(new BuddyServiceException(bcr.Error));
                }
                else
                {
                    tcs.TrySetResult(bcr.Result);
                }
            });
            return tcs.Task;
        }

        /// <summary>
        /// Get a list of Apple groups that have been registered with Buddy as well as the number of users in each group. Groups can be used to batch-send
        /// push notifications to a number of users at the same time.
        /// </summary>
        /// <returns>A Task&lt;IDictionary&lt;String,Int32&gt; &gt;that can be used to monitor progress on this call.</returns>
        public static System.Threading.Tasks.Task<IDictionary<String, Int32>> GetGroupsAsync(this Buddy.NotificationsApple notificationsApple)
        {
            var tcs = new System.Threading.Tasks.TaskCompletionSource<IDictionary<String, Int32>>();
            notificationsApple.GetGroupsInternal((bcr) =>
            {
                if (bcr.Error != BuddyServiceClient.BuddyError.None)
                {
                    tcs.TrySetException(new BuddyServiceException(bcr.Error));
                }
                else
                {
                    tcs.TrySetResult(bcr.Result);
                }
            });
            return tcs.Task;
        }

        /// <summary>
        /// Send a raw message to a Apple device. Note that this call does not directly send the message but rather, adds the raw message to the queue of messages to be sent.
        /// </summary>
        /// <param name="message">The message to send to the user.</param>
        /// <param name="badge">The badge number to set on the icon. It is the application's responsibility to determine what number to set.</param>
        /// <param name="sound">The notification sound to play.</param>
        /// <param name="customItems">Metadata to send with the message for the receiving application to use. Data should be specified as key/value pairs where each key and value are seperated by a comma and each pair is seperated by a ";" character including the last pair ie: key,value;key,value;. Leave empty or set to null if there is no metadata to send.</param>
        /// <param name="senderUserId">The ID of the user that sent the notification.</param>
        /// <param name="deliverAfter">Schedule the message to be delivered after a certain date.</param>
        /// <param name="groupName">Send messages to an entire group of users, not just a one.</param>
        /// <returns>A Task&lt;Boolean&gt;that can be used to monitor progress on this call.</returns>
        public static System.Threading.Tasks.Task<Boolean> SendRawMessageAsync(this Buddy.NotificationsApple notificationsApple, int senderUserId, string message, string badge, string sound, string customItems = "", System.DateTime deliverAfter = default(DateTime), string groupName = "")
        {
            var tcs = new System.Threading.Tasks.TaskCompletionSource<Boolean>();
            notificationsApple.SendRawMessageInternal(senderUserId, message, badge, sound, customItems, deliverAfter, groupName, (bcr) =>
            {
                if (bcr.Error != BuddyServiceClient.BuddyError.None)
                {
                    tcs.TrySetException(new BuddyServiceException(bcr.Error));
                }
                else
                {
                    tcs.TrySetResult(bcr.Result);
                }
            });
            return tcs.Task;
        }
    }

    public static class NotificationsWin8TaskWrappers
    {

        /// <summary>
        /// Register an Win8 device for notificatons with Buddy. 
        /// </summary>
        /// <param name="deviceUri">The URI for the device as returned by the Windows push phone HttpNotificationChannel object.</param>
        /// <param name="clientId">The Package Security Identifier (SID) acquired when the app was registered with the Windows Store Dashboard. </param>
        /// <param name="clientSecret">The secret key corresponding to the SID acquired when the app was registered with the Windows Store Dashboard.</param>
        /// <param name="groupName">Register this device as part of a group, so that you can send the whole group messages.</param>
        /// <returns>A Task&lt;Boolean&gt;that can be used to monitor progress on this call.</returns>
        public static System.Threading.Tasks.Task<Boolean> RegisterDeviceAsync(this Buddy.NotificationsWin8 notificationsWin8, string deviceUri, string clientId, string clientSecret, string groupName = "")
        {
            var tcs = new System.Threading.Tasks.TaskCompletionSource<Boolean>();
            notificationsWin8.RegisterDeviceInternal(deviceUri, clientId, clientSecret, groupName, (bcr) =>
            {
                if (bcr.Error != BuddyServiceClient.BuddyError.None)
                {
                    tcs.TrySetException(new BuddyServiceException(bcr.Error));
                }
                else
                {
                    tcs.TrySetResult(bcr.Result);
                }
            });
            return tcs.Task;
        }

        /// <summary>
        /// Unregister the current user from push notifications for Win8 devices.
        /// </summary>
        /// <returns>A Task&lt;Boolean&gt;that can be used to monitor progress on this call.</returns>
        public static System.Threading.Tasks.Task<Boolean> UnregisterDeviceAsync(this Buddy.NotificationsWin8 notificationsWin8)
        {
            var tcs = new System.Threading.Tasks.TaskCompletionSource<Boolean>();
            notificationsWin8.UnregisterDeviceInternal((bcr) =>
            {
                if (bcr.Error != BuddyServiceClient.BuddyError.None)
                {
                    tcs.TrySetException(new BuddyServiceException(bcr.Error));
                }
                else
                {
                    tcs.TrySetResult(bcr.Result);
                }
            });
            return tcs.Task;
        }

        /// <summary>
        /// Get a paged list of registered Win8 devices for this Application. This list can then be used to iterate over the devices and send each user a push notification.
        /// </summary>
        /// <param name="forGroup">Optionally filter only devices in a certain group.</param>
        /// <param name="pageSize">Set the number of devices that will be returned for each call of this method.</param>
        /// <param name="currentPage">Set the current page.</param>
        /// <returns>A Task&lt;IEnumerable&lt;RegisteredDeviceWin8&gt; &gt;that can be used to monitor progress on this call.</returns>
        public static System.Threading.Tasks.Task<IEnumerable<RegisteredDeviceWin8>> GetRegisteredDevicesAsync(this Buddy.NotificationsWin8 notificationsWin8, string forGroup = "", int pageSize = 10, int currentPage = 1)
        {
            var tcs = new System.Threading.Tasks.TaskCompletionSource<IEnumerable<RegisteredDeviceWin8>>();
            notificationsWin8.GetRegisteredDevicesInternal(forGroup, pageSize, currentPage, (bcr) =>
            {
                if (bcr.Error != BuddyServiceClient.BuddyError.None)
                {
                    tcs.TrySetException(new BuddyServiceException(bcr.Error));
                }
                else
                {
                    tcs.TrySetResult(bcr.Result);
                }
            });
            return tcs.Task;
        }

        /// <summary>
        /// Get a list of Win8 groups that have been registered with Buddy as well as the number of users in each group. Groups can be used to batch-send
        /// push notifications to a number of users at the same time.
        /// </summary>
        /// <returns>A Task&lt;IDictionary&lt;String,Int32&gt; &gt;that can be used to monitor progress on this call.</returns>
        public static System.Threading.Tasks.Task<IDictionary<String, Int32>> GetGroupsAsync(this Buddy.NotificationsWin8 notificationsWin8)
        {
            var tcs = new System.Threading.Tasks.TaskCompletionSource<IDictionary<String, Int32>>();
            notificationsWin8.GetGroupsInternal((bcr) =>
            {
                if (bcr.Error != BuddyServiceClient.BuddyError.None)
                {
                    tcs.TrySetException(new BuddyServiceException(bcr.Error));
                }
                else
                {
                    tcs.TrySetResult(bcr.Result);
                }
            });
            return tcs.Task;
        }

        /// <summary>
        /// Send a image tile to a Win8 device. The tile is represented by a image URL, you can take a look at the Windows phone docs for image dimensions and formats.
        /// </summary>
        /// <param name="xmlPayload">The xml schema describing the tile. Can be specified in the URL using proper character escaping or via the message body. For more information <see href="http:///msdn.microsoft.com/en-us/library/windows/apps/hh761491.aspx" />.</param>
        /// <param name="senderUserId">The ID of the user that sent the notification.</param>
        /// <param name="deliverAfter">Schedule the message to be delivered after a certain date.</param>
        /// <param name="groupName">Send messages to an entire group of users, not just a one.</param>
        /// <returns>A Task&lt;Boolean&gt;that can be used to monitor progress on this call.</returns>
        public static System.Threading.Tasks.Task<Boolean> SendTileAsync(this Buddy.NotificationsWin8 notificationsWin8, string xmlPayload, int senderUserId, System.DateTime deliverAfter = default(DateTime), string groupName = "")
        {
            var tcs = new System.Threading.Tasks.TaskCompletionSource<Boolean>();
            notificationsWin8.SendTileInternal(xmlPayload, senderUserId, deliverAfter, groupName, (bcr) =>
            {
                if (bcr.Error != BuddyServiceClient.BuddyError.None)
                {
                    tcs.TrySetException(new BuddyServiceException(bcr.Error));
                }
                else
                {
                    tcs.TrySetResult(bcr.Result);
                }
            });
            return tcs.Task;
        }

        /// <summary>
        /// Send a badge to a windows 8 device. The app needs to be active and the Raw message callback set in order to recieve this message.
        /// </summary>
        /// <param name="xmlPayload">The message to send.</param>
        /// <param name="senderUserId">The ID of the user that sent the notification.</param>
        /// <param name="deliverAfter">Schedule the message to be delivered after a certain date.</param>
        /// <param name="groupName">Send messages to an entire group of users, not just a one.</param>
        /// <returns>A Task&lt;Boolean&gt;that can be used to monitor progress on this call.</returns>
        public static System.Threading.Tasks.Task<Boolean> SendBadgeAsync(this Buddy.NotificationsWin8 notificationsWin8, string xmlPayload, int senderUserId, System.DateTime deliverAfter = default(DateTime), string groupName = "")
        {
            var tcs = new System.Threading.Tasks.TaskCompletionSource<Boolean>();
            notificationsWin8.SendBadgeInternal(xmlPayload, senderUserId, deliverAfter, groupName, (bcr) =>
            {
                if (bcr.Error != BuddyServiceClient.BuddyError.None)
                {
                    tcs.TrySetException(new BuddyServiceException(bcr.Error));
                }
                else
                {
                    tcs.TrySetResult(bcr.Result);
                }
            });
            return tcs.Task;
        }

        /// <summary>
        /// Send toast message to a windows 8 device. If the app is active the user will recieve this message in the toast message callback. Otherwise the message
        /// appears as a notification on top of the screen. Clicking it will launch the app.
        /// </summary>
        /// <param name="xmlPayload">The xml schema describing the tile. Can be specified in the URL using proper character escaping or via the message body. For more information <see href="http:///msdn.microsoft.com/en-us/library/windows/apps/hh761491.aspx" />.</param>
        /// <param name="senderUserId">The ID of the user that sent the notification.</param>
        /// <param name="deliverAfter">Schedule the message to be delivered after a certain date.</param>
        /// <param name="groupName">Send messages to an entire group of users, not just a one.</param>
        /// <returns>A Task&lt;Boolean&gt;that can be used to monitor progress on this call.</returns>
        public static System.Threading.Tasks.Task<Boolean> SendToastMessageAsync(this Buddy.NotificationsWin8 notificationsWin8, string xmlPayload, int senderUserId, System.DateTime deliverAfter = default(DateTime), string groupName = "")
        {
            var tcs = new System.Threading.Tasks.TaskCompletionSource<Boolean>();
            notificationsWin8.SendToastMessageInternal(xmlPayload, senderUserId, deliverAfter, groupName, (bcr) =>
            {
                if (bcr.Error != BuddyServiceClient.BuddyError.None)
                {
                    tcs.TrySetException(new BuddyServiceException(bcr.Error));
                }
                else
                {
                    tcs.TrySetResult(bcr.Result);
                }
            });
            return tcs.Task;
        }
    }


    public static class PlaceTaskWrappers
    {

        /// <summary>
        /// Set an application specific tag or a user tag for a place.
        /// </summary>
        /// <param name="appTag">The application level tag to set.</param>
        /// <param name="userTag">The user-level tag to set for this Place.</param>
        /// <returns>A Task&lt;Boolean&gt;that can be used to monitor progress on this call.</returns>
        public static System.Threading.Tasks.Task<Boolean> SetTagAsync(this Buddy.Place place, string appTag, string userTag)
        {
            var tcs = new System.Threading.Tasks.TaskCompletionSource<Boolean>();
            place.SetTagInternal(appTag, userTag, (bcr) =>
            {
                if (bcr.Error != BuddyServiceClient.BuddyError.None)
                {
                    tcs.TrySetException(new BuddyServiceException(bcr.Error));
                }
                else
                {
                    tcs.TrySetResult(bcr.Result);
                }
            });
            return tcs.Task;
        }
    }

    public static class PlacesTaskWrappers
    {

        /// <summary>
        /// Find a location close to a given latitude and logitude.
        /// </summary>
        /// <param name="searchDistanceInMeters">The radius of the location search.</param>
        /// <param name="latitude">The latitude where the search should start.</param>
        /// <param name="longitude">The longitude where the search should start.</param>
        /// <param name="numberOfResults">Optional number of result to return, defaults to 10.</param>
        /// <param name="searchForName">Optional search string, for example: "Star*" to search for all place that start with the string "Star"</param>
        /// <param name="searchCategoryId">Optional search category ID to narrow down the search with.</param>
        /// <returns>A Task&lt;IEnumerable&lt;Place&gt; &gt;that can be used to monitor progress on this call.</returns>
        public static System.Threading.Tasks.Task<IEnumerable<Place>> FindAsync(this Buddy.Places places, int searchDistanceInMeters, double latitude, double longitude, int numberOfResults = 10, string searchForName = "", int searchCategoryId = -1)
        {
            var tcs = new System.Threading.Tasks.TaskCompletionSource<IEnumerable<Place>>();
            places.FindInternal(searchDistanceInMeters, latitude, longitude, numberOfResults, searchForName, searchCategoryId, (bcr) =>
            {
                if (bcr.Error != BuddyServiceClient.BuddyError.None)
                {
                    tcs.TrySetException(new BuddyServiceException(bcr.Error));
                }
                else
                {
                    tcs.TrySetResult(bcr.Result);
                }
            });
            return tcs.Task;
        }

        /// <summary>
        /// Get all geo-location categories in Buddy.
        /// </summary>
        /// <returns>A Task&lt;IDictionary&lt;Int32,String&gt; &gt;that can be used to monitor progress on this call.</returns>
        public static System.Threading.Tasks.Task<IDictionary<Int32, String>> GetCategoriesAsync(this Buddy.Places places)
        {
            var tcs = new System.Threading.Tasks.TaskCompletionSource<IDictionary<Int32, String>>();
            places.GetCategoriesInternal((bcr) =>
            {
                if (bcr.Error != BuddyServiceClient.BuddyError.None)
                {
                    tcs.TrySetException(new BuddyServiceException(bcr.Error));
                }
                else
                {
                    tcs.TrySetResult(bcr.Result);
                }
            });
            return tcs.Task;
        }

        /// <summary>
        /// Get a Place by it's globally unique identifier. This method can also be used to calculate a distance from a lat/long to a place.
        /// </summary>
        /// <param name="placeId">The ID of the place to retreive.</param>
        /// <param name="latitude">The optional latitude to calcualte a distance to.</param>
        /// <param name="longitude">The optioanl longitude to calculate a distance to.</param>
        /// <returns>A Task&lt;Place&gt;that can be used to monitor progress on this call.</returns>
        public static System.Threading.Tasks.Task<Place> GetAsync(this Buddy.Places places, int placeId, double latitude = 0, double longitude = 0)
        {
            var tcs = new System.Threading.Tasks.TaskCompletionSource<Place>();
            places.GetInternal(placeId, latitude, longitude, (bcr) =>
            {
                if (bcr.Error != BuddyServiceClient.BuddyError.None)
                {
                    tcs.TrySetException(new BuddyServiceException(bcr.Error));
                }
                else
                {
                    tcs.TrySetResult(bcr.Result);
                }
            });
            return tcs.Task;
        }
    }

    public static class StartupsTaskWrappers
    {

        /// <summary>
        /// Searches for statups by name within the distance of the specified location. Note: To search for all startups within the distance from the specified location, leave the SearchName parameter empty.
        /// </summary>
        /// <param name="searchDistanceInMeters">The radius of the startup search.</param>
        /// <param name="latitude">The latitude where the search should start.</param>
        /// <param name="longitude">The longitude where the search should start.</param>
        /// <param name="numberOfResults">The number of search results to return.</param>
        /// <param name="searchForName">Optional search string, for example: "Star*" to search for all startups that begin with the string "Star".</param>
        /// <returns>A Task&lt;IEnumerable&lt;Startup&gt; &gt;that can be used to monitor progress on this call.</returns>
        public static System.Threading.Tasks.Task<IEnumerable<Startup>> FindAsync(this Buddy.Startups startups, int searchDistanceInMeters, double latitude, double longitude, int numberOfResults=20, string searchForName = "")
        {
            var tcs = new System.Threading.Tasks.TaskCompletionSource<IEnumerable<Startup>>();
            startups.FindInternal(searchDistanceInMeters, latitude, longitude, numberOfResults, searchForName, (bcr) =>
            {
                if (bcr.Error != BuddyServiceClient.BuddyError.None)
                {
                    tcs.TrySetException(new BuddyServiceException(bcr.Error));
                }
                else
                {
                    tcs.TrySetResult(bcr.Result);
                }
            });
            return tcs.Task;
        }

        /// <summary>
        /// Gets a list of the supported metro areas for statups including the URL to an image for each area returned.
        /// </summary>
        /// <returns>A Task&lt;IEnumerable&lt;MetroArea&gt; &gt;that can be used to monitor progress on this call.</returns>
        public static System.Threading.Tasks.Task<IEnumerable<MetroArea>> GetMetroAreaListAsync(this Buddy.Startups startups)
        {
            var tcs = new System.Threading.Tasks.TaskCompletionSource<IEnumerable<MetroArea>>();
            startups.GetMetroAreaListInternal((bcr) =>
            {
                if (bcr.Error != BuddyServiceClient.BuddyError.None)
                {
                    tcs.TrySetException(new BuddyServiceException(bcr.Error));
                }
                else
                {
                    tcs.TrySetResult(bcr.Result);
                }
            });
            return tcs.Task;
        }

        /// <summary>
        /// Get a list of startups in the specified metro area.
        /// </summary>
        /// <param name="metroName">The name of the metro area within which to search for startups.</param>
        /// <param name="recordLimit">The number of search results to return.</param>
        /// <returns>A Task&lt;IEnumerable&lt;Startup&gt; &gt;that can be used to monitor progress on this call.</returns>
        public static System.Threading.Tasks.Task<IEnumerable<Startup>> GetFromMetroAreaAsync(this Buddy.Startups startups, string metroName, int recordLimit)
        {
            var tcs = new System.Threading.Tasks.TaskCompletionSource<IEnumerable<Startup>>();
            startups.GetFromMetroAreaInternal(metroName, recordLimit, (bcr) =>
            {
                if (bcr.Error != BuddyServiceClient.BuddyError.None)
                {
                    tcs.TrySetException(new BuddyServiceException(bcr.Error));
                }
                else
                {
                    tcs.TrySetResult(bcr.Result);
                }
            });
            return tcs.Task;
        }
    }

    public static class VirtualAlbumTaskWrappers
    {

        /// <summary>
        /// Delete this virtual album.
        /// </summary>
        /// <returns>A Task&lt;Boolean&gt;that can be used to monitor progress on this call.</returns>
        public static System.Threading.Tasks.Task<Boolean> DeleteAsync(this Buddy.VirtualAlbum virtualAlbum)
        {
            var tcs = new System.Threading.Tasks.TaskCompletionSource<Boolean>();
            virtualAlbum.DeleteInternal((bcr) =>
            {
                if (bcr.Error != BuddyServiceClient.BuddyError.None)
                {
                    tcs.TrySetException(new BuddyServiceException(bcr.Error));
                }
                else
                {
                    tcs.TrySetResult(bcr.Result);
                }
            });
            return tcs.Task;
        }

        /// <summary>
        /// Add an existing (uploaded) photo to a virtual album. This photo can be either private or public (either PicturePublic and Picture will work).
        /// </summary>
        /// <param name="picture">The picture to add to the virtual albums. Either PicturePublic or Picture works.</param>
        /// <returns>A Task&lt;Boolean&gt;that can be used to monitor progress on this call.</returns>
        public static System.Threading.Tasks.Task<long> AddPictureAsync(this Buddy.VirtualAlbum virtualAlbum, Buddy.PicturePublic picture)
        {
            var tcs = new System.Threading.Tasks.TaskCompletionSource<long>();
            virtualAlbum.AddPictureInternal(picture, (bcr) =>
            {
                if (bcr.Error != BuddyServiceClient.BuddyError.None)
                {
                    tcs.TrySetException(new BuddyServiceException(bcr.Error));
                }
                else
                {
                    tcs.TrySetResult(bcr.Result);
                }
            });
            return tcs.Task;
        }

        /// <summary>
        /// Add a list of pictures to this virtual album.
        /// </summary>
        /// <param name="pictures">The list of pictures to add to this photo album. Either PicturePublic or Picture works.</param>
        /// <returns>A Task&lt;Boolean&gt;that can be used to monitor progress on this call.</returns>
        public static System.Threading.Tasks.Task<Boolean> AddPictureBatchAsync(this Buddy.VirtualAlbum virtualAlbum, System.Collections.Generic.List<Buddy.PicturePublic> pictures)
        {
            var tcs = new System.Threading.Tasks.TaskCompletionSource<Boolean>();
            virtualAlbum.AddPictureBatchInternal(pictures, (bcr) =>
            {
                if (bcr.Error != BuddyServiceClient.BuddyError.None)
                {
                    tcs.TrySetException(new BuddyServiceException(bcr.Error));
                }
                else
                {
                    tcs.TrySetResult(bcr.Result);
                }
            });
            return tcs.Task;
        }

        /// <summary>
        /// Remove a picture from this virtual album.
        /// </summary>
        /// <param name="picture">The picture to remove from the album. Either PicturePublic or Picture works.</param>
        /// <returns>A Task&lt;Boolean&gt;that can be used to monitor progress on this call.</returns>
        public static System.Threading.Tasks.Task<Boolean> RemovePictureAsync(this Buddy.VirtualAlbum virtualAlbum, Buddy.PicturePublic picture)
        {
            var tcs = new System.Threading.Tasks.TaskCompletionSource<Boolean>();
            virtualAlbum.RemovePictureInternal(picture, (bcr) =>
            {
                if (bcr.Error != BuddyServiceClient.BuddyError.None)
                {
                    tcs.TrySetException(new BuddyServiceException(bcr.Error));
                }
                else
                {
                    tcs.TrySetResult(bcr.Result);
                }
            });
            return tcs.Task;
        }

        /// <summary>
        /// Update this virtul albums name and app.tag
        /// </summary>
        /// <param name="newName">The new name for the album.</param>
        /// <param name="newAppTag">An optional new application tag for the album.</param>
        /// <returns>A Task&lt;Boolean&gt;that can be used to monitor progress on this call.</returns>
        public static System.Threading.Tasks.Task<Boolean> UpdateAsync(this Buddy.VirtualAlbum virtualAlbum, string newName, string newAppTag = "")
        {
            var tcs = new System.Threading.Tasks.TaskCompletionSource<Boolean>();
            virtualAlbum.UpdateInternal(newName, newAppTag, (bcr) =>
            {
                if (bcr.Error != BuddyServiceClient.BuddyError.None)
                {
                    tcs.TrySetException(new BuddyServiceException(bcr.Error));
                }
                else
                {
                    tcs.TrySetResult(bcr.Result);
                }
            });
            return tcs.Task;
        }

        /// <summary>
        /// Update virtual album picture comment or app.tag.
        /// </summary>
        /// <param name="picture">The picture to be updated, either PicturePublic or Picture works.</param>
        /// <param name="newComment">The new comment to set for the picture.</param>
        /// <param name="newAppTag">An optional new application tag for the picture.</param>
        /// <returns>A Task&lt;Boolean&gt;that can be used to monitor progress on this call.</returns>
        public static System.Threading.Tasks.Task<Boolean> UpdatePictureAsync(this Buddy.VirtualAlbum virtualAlbum, Buddy.PicturePublic picture, string newComment, string newAppTag = "")
        {
            var tcs = new System.Threading.Tasks.TaskCompletionSource<Boolean>();
            virtualAlbum.UpdatePictureInternal(picture, newComment, newAppTag, (bcr) =>
            {
                if (bcr.Error != BuddyServiceClient.BuddyError.None)
                {
                    tcs.TrySetException(new BuddyServiceException(bcr.Error));
                }
                else
                {
                    tcs.TrySetResult(bcr.Result);
                }
            });
            return tcs.Task;
        }
    }

    public static class VirtualAlbumsTaskWrappers
    {

        /// <summary>
        /// Create a new virtual album. Note that this method internally does two web-service calls, and the IAsyncResult object
        /// returned is only valid for the first one.
        /// </summary>
        /// <param name="name">The name of the new virtual album.</param>
        /// <param name="appTag">An optional application tag for the album.</param>
        /// <returns>A Task&lt;VirtualAlbum&gt;that can be used to monitor progress on this call.</returns>
        public static System.Threading.Tasks.Task<VirtualAlbum> CreateAsync(this Buddy.VirtualAlbums virtualAlbums, string name, string appTag = "")
        {
            var tcs = new System.Threading.Tasks.TaskCompletionSource<VirtualAlbum>();
            virtualAlbums.CreateInternal(name, appTag, (bcr) =>
            {
                if (bcr.Error != BuddyServiceClient.BuddyError.None)
                {
                    tcs.TrySetException(new BuddyServiceException(bcr.Error));
                }
                else
                {
                    tcs.TrySetResult(bcr.Result);
                }
            });
            return tcs.Task;
        }

        /// <summary>
        /// Get a virtual album by its globally unique identifier. All the album photos will be retreived as well. Note that this method internally does two web-service calls, and the IAsyncResult object
        /// returned is only valid for the first one.
        /// </summary>
        /// <param name="albumId">The ID of the virtual album to retrieve.</param>
        /// <returns>A Task&lt;VirtualAlbum&gt;that can be used to monitor progress on this call.</returns>
        public static System.Threading.Tasks.Task<VirtualAlbum> GetAsync(this Buddy.VirtualAlbums virtualAlbums, int albumId)
        {
            var tcs = new System.Threading.Tasks.TaskCompletionSource<VirtualAlbum>();
            virtualAlbums.GetInternal(albumId, (bcr) =>
            {
                if (bcr.Error != BuddyServiceClient.BuddyError.None)
                {
                    tcs.TrySetException(new BuddyServiceException(bcr.Error));
                }
                else
                {
                    tcs.TrySetResult(bcr.Result);
                }
            });
            return tcs.Task;
        }

        /// <summary>
        /// Get the IDs of all the virtual albums that this user owns.
        /// </summary>
        /// <returns>A Task&lt;IEnumerable&lt;Int32&gt; &gt;that can be used to monitor progress on this call.</returns>
        public static System.Threading.Tasks.Task<IEnumerable<Int32>> GetMyAsync(this Buddy.VirtualAlbums virtualAlbums)
        {
            var tcs = new System.Threading.Tasks.TaskCompletionSource<IEnumerable<Int32>>();
            virtualAlbums.GetMyInternal((bcr) =>
            {
                if (bcr.Error != BuddyServiceClient.BuddyError.None)
                {
                    tcs.TrySetException(new BuddyServiceException(bcr.Error));
                }
                else
                {
                    tcs.TrySetResult(bcr.Result);
                }
            });
            return tcs.Task;
        }
    }
}
#endif
